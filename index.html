<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8" />
    <title>Home - jimpex docs</title>
    
    
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <link type="text/css" rel="stylesheet" href="styles/prettify.css" />
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css" />
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no" />
    <link rel="shortcut icon" href="icons/favicon-48.png" />
    <link rel="apple-touch-icon" sizes="48x48" href="icons/favicon-48.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="icons/favicon-72.png" />
    <link rel="apple-touch-icon" sizes="96x96" href="icons/favicon-96.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="icons/favicon-144.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="icons/favicon-192.png" />
    <link rel="apple-touch-icon" sizes="256x256" href="icons/favicon-256.png" />
    <link rel="apple-touch-icon" sizes="384x384" href="icons/favicon-384.png" />
    <link rel="apple-touch-icon" sizes="512x512" href="icons/favicon-512.png" />
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html" class="home-link">jimpex</a></h2><ul class="ref-links">
            <li><a
                class="ref-link -yarn"
                title="View the package on Yarn"
                href="https://yarnpkg.com/package/jimpex"
                target="_blank"
            >View the package on Yarn</a></li>
        

            <li><a
                class="ref-link -github"
                title="Go to the GitHub repository"
                href="https://github.com/homer0/jimpex"
                target="_blank"
            >Go to the GitHub repository</a></li>
        

            <li><a
                class="ref-link -npm"
                title="View the package on NPM"
                href="https://www.npmjs.com/package/jimpex"
                target="_blank"
            >View the package on NPM</a></li>
        </ul><h3>Modules</h3><ul><li><a href="module-constants.html">constants</a></li><li><a href="module-controllers.html">controllers</a></li><li><a href="module-core.html">core</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core.html#~jimpex">jimpex</a></li></ul></li><li><a href="module-functions.html">functions</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-functions.html#.createRouteExpression">createRouteExpression</a></li><li data-type='method' style='display: none;'><a href="module-functions.html#.escapeForRegExp">escapeForRegExp</a></li><li data-type='method' style='display: none;'><a href="module-functions.html#.removeLeadingSlash">removeLeadingSlash</a></li><li data-type='method' style='display: none;'><a href="module-functions.html#.removeSlashes">removeSlashes</a></li><li data-type='method' style='display: none;'><a href="module-functions.html#.removeTrailingSlash">removeTrailingSlash</a></li></ul></li><li><a href="module-middlewares.html">middlewares</a></li><li><a href="module-services.html">services</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-services.html#.appErrorGenerator">appErrorGenerator</a></li><li data-type='method' style='display: none;'><a href="module-services.html#.httpErrorGenerator">httpErrorGenerator</a></li><li data-type='method' style='display: none;'><a href="module-services.html#.sendFile">sendFile</a></li></ul></li><li><a href="module-wrappers.html">wrappers</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-wrappers.html#.controller">controller</a></li><li data-type='method' style='display: none;'><a href="module-wrappers.html#.controllerCreator">controllerCreator</a></li><li data-type='method' style='display: none;'><a href="module-wrappers.html#.middleware">middleware</a></li><li data-type='method' style='display: none;'><a href="module-wrappers.html#.middlewareCreator">middlewareCreator</a></li></ul></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-controllers.html">controllers</a></li><li><a href="tutorial-middlewares.html">middlewares</a></li><li><a href="tutorial-options.html">options</a></li><li><a href="tutorial-services.html">services</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3> </h3>		
    </section>









    



    <section class="readme usertext">
        <article><h1>Jimpex</h1>
<p><a href="https://github.com/homer0/jimpex/actions?query=workflow%3ATest"><img src="https://img.shields.io/github/workflow/status/homer0/jimpex/Test/main?style=flat-square" alt="GitHub Workflow Status (main)"></a>
<a href="https://coveralls.io/github/homer0/jimpex?branch=main"><img src="https://img.shields.io/coveralls/github/homer0/jimpex.svg?style=flat-square" alt="Coveralls GitHub"></a>
<a href="https://david-dm.org/homer0/jimpex"><img src="https://img.shields.io/david/homer0/jimpex.svg?style=flat-square" alt="David"></a>
<a href="https://david-dm.org/homer0/jimpex"><img src="https://img.shields.io/david/dev/homer0/jimpex.svg?style=flat-square" alt="David"></a></p>
<p>Express as dependency injection container.</p>
<p>Jimpex is an implementation of <a href="https://expressjs.com">Express</a>, one of the most popular web frameworks for Node, using <a href="https://github.com/fjorgemota/jimple">Jimple</a>, a Javascript port of <a href="https://pimple.symfony.com">Pimple</a> dependency injection container.</p>
<h2>Usage</h2>
<h3>Creating your app</h3>
<p>You have two ways of creating an app: by defining a class and using the <code>boot</code> method to add all your services and customizations; or with the <code>jimpex</code> function:</p>
<h4>Class</h4>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
// OR import { Jimpex } from 'jimpex/esm';

class MyApp extends Jimpex {
  boot() {
    // Do all your custom stuff...
    this.register(...);
    this.mount(...);
  }
}
</code></pre>
<p>The class constructor has two parameters:</p>
<pre class="prettyprint source lang-js"><code>(options = {}, configuration = null) => Jimpex
</code></pre>
<ol>
<li>The options to customize the application. You can read about them on the <a href="tutorial-options.html">Jimpex Options documentation</a>.</li>
<li>The default configuration, in case you don't want Jimpex to try loading an external configuration file.</li>
</ol>
<p>When definining the application as a class, there are two <em>protected</em> (helper) methods that you can use to overwrite the options and even define priority resources that the implementation could access/overwrite if they manually handle the &quot;boot&quot;:</p>
<h5>Adding resources that can be overriden</h5>
<pre class="prettyprint source lang-js"><code>class MyApp extends Jimpex {
  _init() {
    this.set('env', 'PROD');
  }
}
</code></pre>
<p>The <code>_init</code> method is called before <code>boot</code> gets validated, so even if the constructor option <code>boot</code> is set to <code>false</code>, <code>_init</code> will be called.</p>
<p>Now, let's say you want to execute the application on a development environment; instead of adding <code>if</code>s to check the environment, you could do something like this on your development file:</p>
<pre class="prettyprint source lang-js"><code>const MyApp = require('...');

const app = new MyApp({ boot: false });
app.set('env', 'DEV');
app.boot();
...
</code></pre>
<h5>Modifying the options</h5>
<pre class="prettyprint source lang-js"><code>class MyApp extends Jimpex {
  _initOptions() {
    return {
      configuration: {
        loadFromEnvironment: false,
      },
    };
  }
}
</code></pre>
<p>If you are subclassing <code>Jimpex</code>, it highly probable that if the default options need to be changed, you would want to do it from within the class, rather than forcing all implementations to do it.</p>
<p>One way would be to overwrite the constructor and call <code>super</code> with the customizations, the other would be using this method: The constructor automatically merges the result of <code>_initOptions</code> on top of the defaults so you won't have to override anything.</p>
<p>There are a lot of different options, so I would recommend reading the <a href="tutorial-options.html">Jimpex Options documentation</a>.</p>
<h4>Function</h4>
<pre class="prettyprint source lang-js"><code>const { jimpex } = require('jimpex');
// OR import { jimpex } from 'jimpex/esm';

const app = jimpex();
app.register(...);
app.mount(...);
</code></pre>
<p>The idea of the function is to be used on scenarios where a class may be too much or you have a single implementation, like on a lamda serverless.</p>
<p>The function has almost the same signature as the class constructor:</p>
<pre class="prettyprint source lang-js"><code>(options = {}, configuration = null) => Jimpex
</code></pre>
<ol>
<li>The options to customize the application. You can read about them on the <a href="tutorial-options.html">Jimpex Options documentation</a>.</li>
<li>The default configuration. The big difference here is that, even if you send <code>null</code>, Jimpex won't try to load an external configuration file.</li>
</ol>
<h4>App configuration</h4>
<p>Jimpex, by default, depends on external configuration files and, as a base configuration, it will try to load <code>./config/app/app.config.js</code>. Of course this is extremely configurable through the <a href="tutorial-options.html">Jimpex Options</a>.</p>
<p>A configuration file is just a Javascript file that exports an Object, for example:</p>
<pre class="prettyprint source lang-js"><code>module.exports = {
  port: 2509,
};
</code></pre>
<blockquote>
<p>If that's how you default configuration file looks like, the app will run on the port <code>2509</code>.</p>
</blockquote>
<p>If you don't want the application to load an external file, you could use the second parameter of either the class or the function:</p>
<pre class="prettyprint source lang-js"><code>new MyApp({ ... }, { port: 2509 });
// OR
jimpex({ ... }, { port: 2509 });
</code></pre>
<p>Now, to access the configuration service, you just call <code>appConfiguration</code>:</p>
<pre class="prettyprint source lang-js"><code>const config = app.get('appConfiguration');
</code></pre>
<p>Then you can read its settings using <code>.get(setting)</code>:</p>
<pre class="prettyprint source lang-js"><code>console.log(config.get('port'));
// Will log 2509
</code></pre>
<p>To get more information about how the <code>appConfiguration</code> service works, you can check <a href="https://github.com/homer0/wootils/blob/main/documents/node/appConfiguration.md">its documentation on the wootils repository</a>.</p>
<h4>Starting the application</h4>
<pre class="prettyprint source lang-js"><code>app.listen(2509, () => {
  console.log('The app is running!');
});
</code></pre>
<p>Just like any other Node server, you can use the <code>listen</code> method and specify a port and a callback.</p>
<p>Now, if you you already have a <code>port</code> set on the configuration, you could use the <code>start</code> method; it works just like listen but it only receives a callback:</p>
<pre class="prettyprint source lang-js"><code>app.start(() => {
  console.log('The app is running!');
});
</code></pre>
<p>And finally, you can also stop the application by calling...</p>
<pre class="prettyprint source lang-js"><code>app.stop();
// Done, the app is not longer running.
</code></pre>
<h3>HTTPS &amp;&amp; HTTP2</h3>
<p>To enable HTTPS on your application, just like for the <code>port</code>, you need to create a <code>https</code> key on your configuration, &quot;enable it&quot; and provide the paths for the credentials:</p>
<pre class="prettyprint source lang-js"><code>module.exports = {
  port: 2509,
  https: {
    enabled: true,
    credentials: {
      cert: 'cert-file',
      key: 'key-file',
    },
  },
};
</code></pre>
<p>By default, Jimpex will look for those files relative to the project root directory, but you can change so it will look on a path relative to the directory where the application executable is located:</p>
<pre class="prettyprint source lang-js"><code>{
  // ...
  credentials: {
    onHome: false,
    cert: 'cert-file',
    key: 'key-file',
  },
}
</code></pre>
<p>Also, once you have HTTPS enabled, you can also enable <a href="https://en.wikipedia.org/wiki/HTTP/2">HTTP/2</a>:</p>
<pre class="prettyprint source lang-js"><code>module.exports = {
  port: 2509,
  https: {
    enabled: true,
    credentials: {
      cert: 'cert-file',
      key: 'key-file',
    },
  },
  http2: {
    enabled: true,
  },
};
</code></pre>
<blockquote>
<p><strong>Important:</strong> HTTPS MUST BE enabled in order to use HTTP/2.</p>
</blockquote>
<p>Under the hood, Jimpex uses <a href="https://yarnpkg.com/package/spdy">Spdy</a> for the HTTP/2 support, and Spdy has custom options you can send in order to define how it will work; you can send options to Spdy by adding a <code>spdy</code> key inside the <code>http2</code> object:</p>
<pre class="prettyprint source lang-js"><code>{
  // ...
  http2: {
    enabled: true,
    spdy: {
      'x-forwarded-for': '127.0.0.1',
    },
  },
}
</code></pre>
<h3>Defining a service</h3>
<p>To define a service and its provider, you would write your service as a <code>class</code> or a <code>function</code> and then wrap it on the <code>provider</code> function Jimpex exports:</p>
<pre class="prettyprint source lang-js"><code>const { provider } = require('jimpex');

// Create your service
class MyService {
  constructor(depOne, depTwo);
}

// Define the provider
const myService = provider((app) => {
  app.set('myService', () => new MyService(
    app.get('depOne'),
    app.get('depTwo')
  ));
});

// Export the service and its provider
module.exports.MyService = MyService;
module.exports.myService = myService;
</code></pre>
<blockquote>
<ol>
<li>You could just export the provider, but I believe is a good practice to export both in case another part of your app wants to extend the class and overwrite the service on the container.</li>
<li>That why of using <code>module.expots</code> is so the class can be imported on JSDoc comments.</li>
</ol>
</blockquote>
<p>Then, on you app, you would simple <code>register</code> the provider:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { myService } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.register(myService);
  }
}
</code></pre>
<p>Done, your service is now available.</p>
<h4>Defining a configurable service</h4>
<p>In case you want to create a service that could accept custom setting when instantiated, you can use a <em>&quot;provider creator&quot;</em>:</p>
<pre class="prettyprint source lang-js"><code>const { providerCreator } = require('jimpex');

// Create your service
class MyService {
  constructor(depOne, depTwo, options = {});
}

// Define the provider
const myService = providerCreator((options) => (app) => {
  app.set('myService', () => new MyService(
    app.get('depOne'),
    app.get('depTwo'),
    settings
  ));
});

// Export the service and its provider
module.exports = {
  MyService,
  myService,
};
</code></pre>
<p>The special behavior the creators have, is that you can call them as a function, sending the settings, or just use them on the <code>register</code>, so <strong>it's very important that the settings must be optional</strong>:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { myService } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.register(myService);
    // or
    this.register(myService({ ... }));
  }
}
</code></pre>
<h3>Adding a controller</h3>
<p>To add controller you need to use the <code>controller</code> function and return a list of routes:</p>
<pre class="prettyprint source lang-js"><code>const { controller } = require('jimpex');

// (Optional) Define a class to organize your route handlers.
class HealthController {
  health() {
    return (req, res) => {
      res.write('Everything works!');
    };
  }
}

// Define the controller
const healthController = controller((app) => {
  const ctrl = new HealthController();
  // Get the router service
  const router = app.get('router');
  // Return the router with all the routes
  return router
  .get('/', ctrl.health())
  .get(...);
});

// Export the controller class and the controller itself
module.exports.HealthController = HealthController;
module.exports.healthController = healthController;
</code></pre>
<blockquote>
<ol>
<li>You could just export the controller, but I believe is a good practice to export both in case another part of your app wants to extend the class and mount a new route withs its inherit functionalities.</li>
<li>That why of using <code>module.expots</code> is so the class can be imported on JSDoc comments.</li>
<li>The function inside the <code>controller</code> wrapper won't be called until the app is started. In case you are wondering about the lazy loading of the services that you may inject.</li>
</ol>
</blockquote>
<p>Then, on you app, you would <code>mount</code> the controller:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { healthController } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.mount('/health', healthController);
  }
}
</code></pre>
<h4>Defining a configurable controller</h4>
<p>Like with _&quot;providers creators&quot;, you can define controllers that accept custom settings when
instantiated, using a <em>&quot;controller creator&quot;</em>:</p>
<pre class="prettyprint source lang-js"><code>const { controllerCreator } = require('jimpex');

// (Optional) Define a class to organize your route handlers.
class HealthController {
  constructor(settings = {});

  health() {
    return (req, res) => {
      res.write('Everything works!');
    };
  }
}

// Define the controller
const healthController = controllerCreator((settings) => (app) => {
  const ctrl = new HealthController(settings);
  // Get the router service
  const router = app.get('router');
  // Return the router with all the routes
  return router
  .get('/', ctrl.health())
  .get(...);
});

// Export the controller class and the controller itself
module.exports.HealthController = HealthController;
module.exports.healthController = healthController;
</code></pre>
<p>The special behavior the creators have, is that you can call them as a function, sending the settings, or just use them with <code>mount</code> as regular controllers; and since they can be used as regular controllers, <strong>it's very important that the settings are optional</strong>:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { healthController } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.mount('/health', healthController);
    // or
    this.mount('/health', healthController({ ... }));
  }
}
</code></pre>
<h4>Defining a controller that registers a service</h4>
<p>If for some reason, your controller needs to register a service the rest of the container needs to have access to and you plan to do it on the <code>controller</code>/<code>controllerCreator</code> callback, you could end up messing with the <em>lazyness</em> of the container: If a middleware or another controller tries to access the service and the controller that registers it is mounter after it, it will get an error as the service doesn't exist yet.</p>
<p>To solve this issue, you can use a &quot;controller provider&quot;:</p>
<pre class="prettyprint source lang-js"><code>const { provider, controller } = require('jimpex');

// (Optional) Define a class to organize your route handlers.
class HealthController {
  health() {
    return (req, res) => {
      res.write('Everything works!');
    };
  }
}

// Define the controller
const healthController = provider(app) => {
  // Register the controller as a service (or any other resource)
  app.set('health', () => new HealthController());
  return controller(() => {
    // Get the controller as a service
    const ctrl = app.get('health');
    // Get the router service
    const router = app.get('router');
    // Return the router with all the routes
    return router
    .get('/', ctrl.health())
    .get(...);
  });
});

// Export the controller class and the controller itself
module.exports.HealthController = HealthController;
module.exports.healthController = healthController;
</code></pre>
<p>And you would mount it just like any other contorller:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { healthController } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.mount('/health', healthController);
  }
}
</code></pre>
<p>And in the case you need a &quot;creator&quot;, you could use a &quot;provider creator&quot; and return a controller:</p>
<pre class="prettyprint source lang-js"><code>const healthController = providerCreator((settings) => (app) => {
  // Register the controller as a service (or any other resource) and send the settings
  app.set('health', () => new HealthController(settings));
  return controller(() => {
    // Get the controller as a service
    const ctrl = app.get('health');
    // Get the router service
    const router = app.get('router');
    // Return the router with all the routes
    return router
    .get('/', ctrl.health())
    .get(...);
  });
});
</code></pre>
<h3>Adding a middleware</h3>
<p>To add a new middleware you need to use the <code>middleware</code> function and return a function:</p>
<pre class="prettyprint source lang-js"><code>const { middlware } = require('jimpex');

// Define your middleware function (or class if it gets more complex)
const greetingsMiddleware = () => (req, res, next) => {
  console.log('Hello!');
};

// Define the middleware
const greetings = middleware(() => greetingsMiddleware());

// Export the function and the middleware
module.exports.greetingsMiddleware = greetingsMiddleware;
module.exports.greetings = greetings;
</code></pre>
<blockquote>
<ol>
<li>You could just export the provider, but I believe is a good practice to export both in case another part of your app wants to extend the class or use the function.</li>
<li>That why of using <code>module.expots</code> is so the function can be imported on JSDoc comments.</li>
</ol>
</blockquote>
<p>Then, on you app, you would <code>use</code> the controller:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { greetings } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.use(greetings);
  }
}
</code></pre>
<h4>Defining a configurable middleware</h4>
<p>Like with controllers and providers, you can also create a middleware that can accept settings when instantiated, with a <em>&quot;middleware creator&quot;</em>:</p>
<pre class="prettyprint source lang-js"><code>const { middlwareCreator } = require('jimpex');

// Define your middleware function (or class if it gets more complex)
const greetingsMiddleware = (message = 'Hello!') => (req, res, next) => {
  console.log(message);
};

// Define the middleware
const greetings = middlewareCreator((message) => greetingsMiddleware(message));

// Export the function and the middleware
module.exports.greetingsMiddleware = greetingsMiddleware;
module.exports.greetings = greetings;
</code></pre>
<p>The special behavior the creators have, is that you can call them as a function, sending the settings, or just register them with <code>use</code> as regular middlewares, so <strong>it's very important that the settings must be optional</strong>:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { greetings } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.use(greetings);
    // or
    this.use(greetings('Howdy!'));
  }
}
</code></pre>
<h4>Defining a middleware that registers a service</h4>
<p>Just like the &quot;controller provider&quot;, you can also create a &quot;middleware provider&quot;, a middleware that also registers something on the contianer without messing with the <em>lazyness</em> of the container:</p>
<pre class="prettyprint source lang-js"><code>const { provider, middleware } = require('jimpex');
// Define the class that will work as a service
class Greeter {
  // Add a method that could be used on its &quot;service role&quot;
  greet() {
    return 'Hello!';
  }
  // Add a method for the actual middleware
  middleware() {
    return (req, res, next) => {
      console.log(this.greet());
    };
  }
}
// Define the provider
const greetings = provider((app) => {
  // Register the class as a service
  app.set('greeter', () => new Greeter());
  // Return the actual middleware
  return middleware(() => app.get('greeter').middleware());
})

// Export the class and the provider
module.exports.greetingsMiddleware = greetingsMiddleware;
module.exports.greetings = greetings;
</code></pre>
<p>And you would mount it just like any other contorller:</p>
<pre class="prettyprint source lang-js"><code>const { Jimpex } = require('jimpex');
const { greetings } = require('...');

class MyApp extends Jimpex {
  boot() {
    ...
    this.use(greetings);
  }
}
</code></pre>
<p>And in the case you need a &quot;creator&quot;, you could use a &quot;provider creator&quot; and return a controller:</p>
<pre class="prettyprint source lang-js"><code>const greetings = providerCreator((settings) => (app) => {
  // Register the class as a service and send the settings
  app.set('greeter', () => new Greeter(settings));
  // Return the actual middleware
  return middleware(() => app.get('greeter').middleware());
});
</code></pre>
<h3>Proxy mode</h3>
<p>You can enable the &quot;proxy mode&quot; by setting the <code>proxy</code> option to <code>true</code> on either the function or the class and it allows you to access and register resources using dot notation:</p>
<pre class="prettyprint source lang-js"><code>// Set the option
const app = jimpex({ proxy: true });

app.myService = () => new MyService();
// = app.set('myService', () => new MyService();

app.myService.doSomething();
// = app.get('myService').doSomething();

doSomething(app.$myService);
// = doSomething(app.try('myService'));
</code></pre>
<p>When using the class, as you would expect, the constructor would give you the original instance and then you would have to call <code>.ref()</code> to get either the proxy or the original (depending on the setting):</p>
<pre class="prettyprint source lang-js"><code>const original = new Jimpex({ proxy: true });
const app = original.ref();
</code></pre>
<p>But for the function, what you get as return value is actually the call for <code>.ref()</code>, that's why the first example could use the proxy mode without calling it.</p>
<p>Internally, when <code>proxy</code> is enabled, all providers, controllers and middlewares will receive the proxy instead of the original.</p>
<h2>Built-in features</h2>
<p>Jimpex comes with a few services, middlewares and controllers that you can import and use on your app, some of them <a href="tutorial-options.html">are activated by default on the options</a>, but others you have to implement manually:</p>
<h3>Controllers</h3>
<ul>
<li><strong>Configuration:</strong> Allows you to see and switch the current configuration. It can be enabled or disabled by using a setting on the configuration.</li>
<li><strong>Health:</strong> Shows the version and name of the configuration, just to check the app is running.</li>
<li><strong>Statics:</strong> It allows your app to server specific files from any directory, without having to use the <code>static</code> middleware.</li>
<li><strong>Gateway:</strong> It allows you to automatically generate a set of routes that will make gateway requests to an specific API.</li>
</ul>
<p><a href="tutorial-controllers.html">Read more about the built-in controllers</a></p>
<h3>Middlewares</h3>
<ul>
<li><strong>Error handler:</strong> Allows you to generate responses for errors and potentially hide uncaught exceptions under a generic message, unless it's disabled via configuration settings.</li>
<li><strong>Force HTTPS:</strong> Redirect all incoming traffic from HTTP to HTTPS. It also allows you to set routes to ignore the redirection.</li>
<li><strong>HSTS header:</strong> It configures a <code>Strict-Transport-Security</code> header and includes it on every response.</li>
<li><strong>Fast HTML:</strong> Allows your app to skip unnecessary processing by showing an specific HTML when a requested route doesn't have a controller for it or is not on a &quot;whitelist&quot;.</li>
<li><strong>Show HTML:</strong> A really simple middleware to serve an HTML file. Its true feature is that it can be hooked up to the <strong>HTML Generator</strong> service.</li>
<li><strong>Version validator:</strong> If you mount it on a route it will generate a <code>409</code> error if the request doesn't have a version parameter with the same version as the one on the configuration.</li>
</ul>
<p><a href="tutorial-middlewares.html">Read more about the built-in controllers</a></p>
<h3>Services</h3>
<ul>
<li><strong>API client:</strong> An implementation of the <a href="https://github.com/homer0/wootils/blob/main/documents/shared/APIClient.md">wootils API Client</a> but that is connected to the HTTP service, to allow logging and forwarding of the headers.</li>
<li><strong>App Error:</strong> A very simple subclass of <code>Error</code> but with support for context information. It can be used to customize the error handler responses.</li>
<li><strong>Ensure bearer token:</strong> A service-middleware that allows you to validate and retrieve a bearer token from the incoming requests <code>Authorization</code> header.</li>
<li><strong>HTTP Error:</strong> Another type of error, but specific for the HTTP requests the app does with the API client.</li>
<li><strong>Send File:</strong> It allows you to send a file on a response with a path relative to the app executable.</li>
<li><strong>Frontend Fs:</strong> Useful for when your app has a bundled frontend, it allows you to read, write and delete files with paths relative to the app executable.</li>
<li><strong>HTML Generator:</strong> A service that allows you to generate an HTML file when the app gets started and inject contents of the configuration as a <code>window</code> variable.</li>
<li><strong>HTTP:</strong> A set of utilities to work with HTTP requests and responses.</li>
<li><strong>Responses builder:</strong> A service that generates JSON and HTML responses.</li>
</ul>
<p><a href="tutorial-services.html">Read more about the built-in services</a></p>
<p>The service also implements a few other services from the <a href="https://github.com/homer0/wootils">wootils</a> as core utilities:</p>
<ul>
<li><a href="https://github.com/homer0/wootils/blob/main/documents/node/logger.md"><code>appLogger</code></a>: The logger service.</li>
<li><a href="https://github.com/homer0/wootils/blob/main/documents/node/environmentUtils.md"><code>environmentUtils</code></a>: The service that reads the environment variables.</li>
<li><a href="https://github.com/homer0/wootils/blob/main/documents/node/packageInfo.md"><code>packageInfo</code></a>: The app package.json information.</li>
<li><a href="https://github.com/homer0/wootils/blob/main/documents/node/pathUtils.md"><code>pathUtils</code></a>: The service to build paths relative to the project root directory.</li>
<li><a href="https://github.com/homer0/wootils/blob/main/documents/node/rootRequire.md"><code>rootRequire</code></a>: The service to make requires relatives to the project root directory.</li>
<li><a href="https://github.com/homer0/wootils/blob/main/documents/shared/eventsHub.md"><code>events</code></a>: To handle the app events.</li>
</ul>
<h2>Development</h2>
<h3>NPM/Yarn Tasks</h3>
<table>
<thead>
<tr>
<th>Task</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>docs</code></td>
<td>Generates the project documentation.</td>
</tr>
<tr>
<td><code>lint</code></td>
<td>Lints the staged files.</td>
</tr>
<tr>
<td><code>lint:all</code></td>
<td>Lints the entire project code.</td>
</tr>
<tr>
<td><code>test</code></td>
<td>Runs the project unit tests.</td>
</tr>
<tr>
<td><code>todo</code></td>
<td>Lists all the pending to-do's.</td>
</tr>
</tbody>
</table>
<h3>Repository hooks</h3>
<p>I use <a href="https://yarnpkg.com/package/husky"><code>husky</code></a> to automatically install the repository hooks so the code will be tested and linted before any commit, and the dependencies updated after every merge.</p>
<h4>Commits convention</h4>
<p>I use <a href="https://www.conventionalcommits.org">conventional commits</a> with <a href="https://commitlint.js.org"><code>commitlint</code></a> in order to support semantic releases. The one that sets it up is actually husky, that installs a script that runs <code>commitlint</code> on the <code>git commit</code> command.</p>
<p>The configuration is on the <code>commitlint</code> property of the <code>package.json</code>.</p>
<h3>Releases</h3>
<p>I use <a href="https://yarnpkg.com/package/semantic-release"><code>semantic-release</code></a> and a GitHub action to automatically release on NPM everything that gets merged to main.</p>
<p>The configuration for <code>semantic-release</code> is on <code>./releaserc</code> and the workflow for the release is on <code>./.github/workflow/release.yml</code>.</p>
<h3>Testing</h3>
<p>I use <a href="https://facebook.github.io/jest/">Jest</a> to test the project.</p>
<p>The configuration file is on <code>./.jestrc.js</code>, the tests are on <code>./tests</code> and the script that runs it is on <code>./utils/scripts/test</code>.</p>
<h3>Code linting and formatting</h3>
<p>For linting, I use <a href="https://eslint.org">ESlint</a> with <a href="https://yarnpkg.com/package/@homer0/eslint-plugin">my own custom configuration</a>; there are two configuration files, <code>./.eslintrc</code> for the source and the tooling, and <code>./tests/.eslintrc</code>, and there's also a <code>./.eslintignore</code> to exclude some files.</p>
<p>And for formatting, I use <a href="https://prettier.io">Prettier</a> with <a href="https://yarnpkg.com/package/@homer0/prettier-plugin-jsdoc">my JSDoc plugin</a> and <a href="https://yarnpkg.com/package/@homer0/prettier-config">my own custom configuration</a>. The configuration file is <code>./.prettierrc</code>.</p>
<p>The script that runs them is <code>./utils/scripts/lint</code>; the script <code>lint-all</code> only runs ESLint, and runs it for the entire project.</p>
<h3>Documentation</h3>
<p>I use <a href="https://jsdoc.app">JSDoc</a> to generate an HTML documentation site for the project.</p>
<p>The configuration file is <code>./.jsdoc.js</code> and the script that runs it is on <code>./utils/scripts/docs</code>.</p>
<h3>To-Dos</h3>
<p>I use <code>@todo</code> comments to write all the pending improvements and fixes, and <a href="https://yarnpkg.com/en/package/leasot">Leasot</a> to generate a report. The script that runs it is on <code>./utils/scripts/todo</code>.</p>
<h2>Motivation/Introduction</h2>
<p>A friend who's also web developer brought the idea of start using a dependency injection container on Node, and how Jimple was a great tool for it, and from that moment on I can't think of starting an app without using it. It not only allows you to implement dependency injection on a simple and clean way but it also kind of forces you to have a really good organization of your code.</p>
<p>A couple of months after that, the same friend told me that we should do something similar to <a href="https://silex.symfony.com/">Silex</a>, which is based on Pimple, with Express. I ran with the idea and... this project is what I think a mix of Jimple and Express would look like. To be clear, <strong>this is not a port of Silex</strong>.</p></article>
    </section>







    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> using a forked <a href="https://github.com/homer0/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>