<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | jimpex</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Express as dependency injection container."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="jimpex"><meta property="twitter:description" content="Express as dependency injection container."></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/jimpex"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/options.html"><a href="manual/options.html" data-ice="link">Jimpex Options</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#configuration" data-ice="link">Configuration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#statics" data-ice="link">Statics</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#express" data-ice="link">Express</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#default-services" data-ice="link">Default services</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/controllers.html"><a href="manual/controllers.html" data-ice="link">Built-in Controllers</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#version-validator" data-ice="link">Version validator</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#configuration" data-ice="link">Configuration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#health" data-ice="link">Health</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#root-statics" data-ice="link">Root Statics</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/middlewares.html"><a href="manual/middlewares.html" data-ice="link">Built-in Middlewares</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#error-handler" data-ice="link">Error Handler</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#force-https" data-ice="link">Force HTTPS</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#fast-html" data-ice="link">Fast HTML</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#show-html" data-ice="link">Show HTML</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/services.html"><a href="manual/services.html" data-ice="link">Built-in Services</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#api-client" data-ice="link">API Client</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#ensure-bearer-authentication" data-ice="link">Ensure bearer authentication</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#version-validator" data-ice="link">Version validator</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#error" data-ice="link">Error</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#send-file" data-ice="link">Send File</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#frontend-fs" data-ice="link">Frontend Fs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#html-generator" data-ice="link">HTML Generator</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#http" data-ice="link">HTTP</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#responses-builder" data-ice="link">Responses builder</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Jimpex Options</h1><p>The options the second parameter of the class constructor and it allows you to customize almost every aspect of Jimpex.</p><p>This is what the options object looks like:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The version of the app
  version: &apos;0.0.0&apos;,

  // The size limit for the requests payload.
  filesizeLimit: &apos;15MB&apos;,

  // The options to customize how the app configuration is loaded (details on its section).
  configuration: ...,

  // The options for the static middleware (details on its section).
  statics: ...,

  // The options to customize the express instance and default middlewares (details on its section).
  express: ...,

  // Which built-in services to register (details on its section).
  defaultServices: ...
}</code>
</code></pre><p>Besides the first two, which default values and descriptions are pretty clear, I&apos;ll go in detail for all the others.</p><h2>Configuration</h2><p>This set of options allows you to customize every aspect of how the configuration service is created. Remember that the app requires a valid configuration with a <code>port</code> setting to be started:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The default configuration. If the value is null, it will load [app-name].config.js
  default: null,

  // The name of the app, to be used on the configurations directory and filenames.
  name: &apos;app&apos;,

  // The path relative to the root directory where the configurations are located.
  path: &apos;config/&apos;,

  // If `true`, the path to the configuration will add a folder with the name of the app.
  hasFolder: true,

  // The environment variable the app will check for a configuration name.
  environmentVariable: &apos;CONFIG&apos;,

  // Whether or not to check for the environment variable.
  loadFromEnvironment: true,

  // If `true`, the version of the app will be copied from the loaded configuration.
  loadVersionFromConfiguration: true,

  // The name format of the configuration files.
  filenameFormat: &apos;[app-name].[configuration-name].config.js&apos;,
}</code>
</code></pre><p>As you can see, if you don&apos;t want to depend on environment variables or just have one single configuration for your app, you can use the <code>default</code> option and turn <code>loadFromEnvironment</code> to <code>false</code>.</p><p>The configuration service is an implementation of <a href="https://github.com/homer0/wootils/blob/master/documents/node/appConfiguration.md">wootils AppConfiguration</a>, so you can check its API in its oficial configuration.</p><h2>Statics</h2><p>These options are specifically for the Express <a href="https://github.com/expressjs/serve-static"><code>static</code></a> middleware:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // Whether or not to enable the middleware to serve statics files.
  enabled: true,

  // If true, the statics folder would be relative to the project root directory, otherwise,
  // it would be relative to the app executable.
  onHome: false,

  // The name of both the route and the folder, relative to whatever you defined with the
  // `onHome` option.
  route: &apos;statics&apos;,

  // By default, the folder will be the same as the `route`, but you can use this option
  // to define a relative path that won&apos;t affect the route.
  folder: &apos;&apos;,
}</code>
</code></pre><h2>Express</h2><p>These are options for miscellaneous things you can add to the Express server:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // Whether or not to enable the `trust proxy` option.
  trustProxy: true,

  // Whether or not to remove the `x-powered-by` header.
  disableXPoweredBy: true,

  // Whether or not to add the `compression` middleware.
  compression: true,

  // Whether or not to add the `body-parser` middleware.
  bodyParser: true,

  // Whether or not to add the `multer` middleware.
  multer: true,
}</code>
</code></pre><h2>Default services</h2><p>These options allow you to register some of the built-in service that I consider useful enough to be added on any app.</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // These services include:
  // - Error handler
  // - Send File
  common: true,

  // These services include:
  // - HTTP
  // - Responses builder
  http: true,

  // These services include:
  // - API client
  // - Ensure bearer authentication
  // - Version validator
  api: true,
}</code>
</code></pre><p>For more information about these services, check the document about <strong>Built-in Services</strong>.</p></div>
        <a data-ice="link" href="manual/options.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Built-in Controllers</h1><p>All of these controllers are available on the Jimpex package and can be easily required and implemented.</p><h2>Version validator</h2><p>If you mount it on a route it will generate a <code>409</code> error if the request doesn&apos;t have a version parameter with the same version as the one on the configuration file.</p><ul>
<li>Module: <code>api</code></li>
<li>Requires: <code>versionValidator</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    api: { versionValidator },
  },
  controllers: {
    api: { versionValidatorController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(versionValidator);

    // Add the controller.
    this.mount(&apos;/api&apos;, versionValidatorController);
  }
}</code>
</code></pre><p>The controller will mount one route:</p><ul>
<li><code>* /:version/*</code>: To validate and protect any sub route.</li>
</ul><p>You can mount other routes on <code>/api/:version/...</code> and they&apos;ll be <em>&quot;protected&quot;</em> by the version check.</p><h2>Configuration</h2><p>Allows you to see and switch the current configuration. It can be enabled or disabled by using a setting on the configuration.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>responsesBuilder</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
  },
  controllers: {
    common: { configurationController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(responsesBuilder);

    // Add the controller.
    this.mount(&apos;/config&apos;, configurationController);
  }
}</code>
</code></pre><p>Now, there are two rules behind this controller:</p><ol>
<li>Your configuration must have a setting <code>debug.configurationController</code> with the value of <code>true</code>.</li>
<li>To be able to switch configurations, the default configuration and/or the first configuration loaded must have a setting <code>allowConfigurationSwitch</code> set to <code>true</code>.</li>
</ol><p>The reason for those rules is that this controller is development purposes as you wouldn&apos;t want to make public the settings of your app.</p><p>The controller then will mount two routes:</p><ul>
<li><code>GET /</code>: It will show the current configuration.</li>
<li><code>GET /switch/:name</code>: It will, if allowed, switch to an specified configuration.</li>
</ul><h2>Health</h2><p>Shows the version and name of the configuration, just to check the app is running.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>responsesBuilder</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
  },
  controllers: {
    common: { healthController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(responsesBuilder);

    // Add the controller.
    this.mount(&apos;/health&apos;, healthController);
  }
}</code>
</code></pre><p>That&apos;s all there is, the controller mounts only one route:</p><ul>
<li><code>GET /</code>: Shows the information.</li>
</ul><h2>Root Statics</h2><p>It allows your app to server static files from the root directory, without having to use the <code>static</code> middleware on that directory.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>sendFile</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  controllers: {
    common: { rootStaticsController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the controller.
    this.mount(&apos;/&apos;, rootStaticsController);
  }
}</code>
</code></pre><p>By default, it serves an <code>index.html</code> and a <code>favicon.ico</code>, but you can use the <em>&quot;controller generator&quot;</em> <code>rootStaticsControllerCustom</code> to modify those values:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  controllers: {
    common: { rootStaticsControllerCustom },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the controller.
    this.mount(&apos;/&apos;, rootStaticsControllerCustom([
      &apos;my-file-one.html&apos;,
      &apos;favicon.icon&apos;,
      &apos;index.html&apos;,
      &apos;some-other.html&apos;,
    ]));
  }
}</code>
</code></pre><p>The controller mounts a <code>GET</code> route for each one of those files.</p></div>
        <a data-ice="link" href="manual/controllers.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Built-in Middlewares</h1><p>All of these controllers are available on the Jimpex package and can be easily required and implemented.</p><h2>Error Handler</h2><p>Allows you to generate responses for errors and potentially hide uncaught exceptions under a generic message, unless it&apos;s disabled via configuration settings.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>responsesBuilder</code> and <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
    common: { appError },
  },
  middlewares: {
    common: { errorHandler },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(responsesBuilder);
    this.register(appError);

    ...

    // Add the middleware at the end.
    this.use(errorHandler);
  }
}</code>
</code></pre><p>Now, there&apos;s a configuration setting for this controller: <code>debug.showErrors</code>. By enabling the setting, the middleware will show the message and the stack information of all kind of errors.</p><p>If the configuration setting is disabled (or not present), the errors stack will never be visible, and if the error is not an instance of the <code>appError</code> service, it will show a generic message: <em>&quot;Oops! Something went wrong, please try again&quot;</em>.</p><p>Now, when using errors of the type <code>appError</code>, you can add the following extra data:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Assuming `AppError` is the injected `appError` and you are on the context of a middleware
next(new AppError(&apos;Something went wrong&apos;, {
  status: someHTTPStatus,
  response: someObject,
}));</code>
</code></pre><ul>
<li><code>status</code> will replace the error responses HTTP status.</li>
<li><code>response</code> will be merged into the error response <code>data</code> key.</li>
</ul><h2>Force HTTPS</h2><p>Redirect all incoming traffic from HTTP to HTTPS. It also allows you to set routes to ignore the redirection.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  middlewares: {
    common: { forceHTTPS },
  },
};

class App extends Jimpex {
  boot() {
    // Add the middleware first.
    this.use(errorHandler);
  }
}</code>
</code></pre><p>By default, it redirects all the URLs that don&apos;t start with <code>/service/</code> from HTTP to HTTPs, but you can use the <em>&quot;middleware generator&quot;</em> <code>forceHTTPSCustom</code> to modify the rules:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  middlewares: {
    common: { forceHTTPSCustom },
  },
};

class App extends Jimpex {
  boot() {
    // Add the middleware first.
    this.use(forceHTTPSCustom([
      /^\/service\//,
      /^\/api\//,
    ]));
  }
}</code>
</code></pre><p><strong>VERY IMPORTANT:</strong> The forced redirection will only happen if your configuration has a setting named <code>forceHTTPS</code> with a value of <code>true</code>.</p><h2>Fast HTML</h2><p>Allows you to specify which routes will be handled and in case there are no controllers for a requested route, it sends out and HTML file, thus preventing the request to be unnecessarily processed by the middlewares.</p><ul>
<li>Module: <code>html</code></li>
<li>Requires: <code>sendFile</code> and, optionally, an <code>HTMLGenerator</code> service.</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { fastHTML },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware on one of the first positions.
    this.use(fastHTML);
  }
}</code>
</code></pre><p>By default, if the requested URL doesn&apos;t match <code>/^\/api\//</code> or <code>/\.ico$/</code> it serves an <code>index.html</code>, but you can use the <em>&quot;middleware generator&quot;</em> <code>fastHTMLCustom</code> to modify those options:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { fastHTMLCustom },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware on one of the first positions.
    this.use(fastHTMLCustom(
      &apos;my-custom-index.html&apos;,
      [`/^\/service\//`]
    ));
  }
}</code>
</code></pre><p>Now, as mentioned on the requirements, you can optionally use the <code>htmlGenerator</code> or an <code>HTMLGenerator</code> service to serve a generated file.</p><p>The default implementation checks if there&apos;s an <code>htmlGenerator</code> service registered on the app and uses that file; and in the case of <code>fastHTMLCustom</code>, you can specify a third parameter with the name of the <code>HTMLGenerator</code> service name you want to use.</p><h2>Show HTML</h2><p>A really simple middleware to serve an HTML file. Its true feature is that it can be hooked up to the <strong>HTML Generator</strong> service.</p><ul>
<li>Module: <code>html</code></li>
<li>Requires: <code>sendFile</code> and, optionally, an <code>HTMLGenerator</code> service.</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { showHTML },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware at the end.
    this.use(showHTML);
  }
}</code>
</code></pre><p>By default, if the middleware is reached, it will show an <code>index.html</code>, but you can use the <em>&quot;middleware generator&quot;</em> <code>showHTMLCustom</code> to modify the filename:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { showHTMLCustom },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware at the end.
    this.use(showHTMLCustom(&apos;my-file.html&apos;));
  }
}</code>
</code></pre><p>Now, as mentioned on the requirements, you can optionally use the <code>htmlGenerator</code> or an <code>HTMLGenerator</code> service to show the generated file.</p><p>The default implementation checks if there&apos;s an <code>htmlGenerator</code> service registered on the app and uses that file; and in the case of <code>showHTMLCustom</code>, you can specify a second parameter with the name of the <code>HTMLGenerator</code> service name you want to use.</p></div>
        <a data-ice="link" href="manual/middlewares.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Built-in Services</h1><p>All of these controllers are available on the Jimpex package and can be easily required and implemented.</p><p>In the case of the services from the modules <code>api</code>, <code>http</code> and <code>common</code>, you can register them when the app starts by using the <code>defaultService</code> option (Check the options document for more information).</p><h2>API Client</h2><p>An implementation of the <a href="https://github.com/homer0/wootils/blob/master/documents/shared/APIClient.md">wootils API Client</a> but that is connected to the HTTP service, to allow logging and forwarding of the headers.</p><ul>
<li>Module: <code>api</code></li>
<li>Requires: <code>http</code> and <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    api: { apiClient },
    common: { appError },
    http: { http },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(http);
    this.register(appError);

    // Register the client
    this.register(apiClient);
  }
}</code>
</code></pre><p>By default, the service is registered with the name <code>apiClient</code>, the API entry point is taken from the configuration setting <code>api.url</code> and the endpoints from <code>api.endpoints</code>, but you can use the <em>&quot;service generator&quot;</em> <code>apiClientCustom</code> to modify those options:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    api: { apiClientCustom },
    common: { appError },
    http: { http },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(http);
    this.register(appError);

    // Register the client
    this.register({
      &apos;myCustomAPIService&apos;,
      &apos;myapi&apos;
    });
  }
}</code>
</code></pre><p>The first parameter is the name used to register the server and the second one is the setting key that has a <code>url</code> and an <code>endpoints</code> dictionary.</p><h2>Ensure bearer authentication</h2><p>A service-middleware that allows you to validate the incoming requests <code>Authorization</code> header.</p><p>It&apos;s a <em>&quot;service-middleware&quot;</em> because when you access the service, it doesn&apos;t return a class instance, but a middleware function for you to use on your controller routes.</p><ul>
<li>Module: <code>api</code></li>
<li>Requires: <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    api: { ensureBearerAuthentication },
    common: { appError },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(appError);

    // Register the service
    this.register(apiClient);
  }
}</code>
</code></pre><p>Now, if the token process a request an detects a valid token, it will set that token on the request <code>bearerToken</code> property:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myCtrl = controller((app) =&gt; {
  const router = app.get(&apos;router&apos;);
  const ensureAuthentication = app.get(&apos;ensureBearerAuthentication&apos;);
  return [router.get(&apos;/something&apos;, [
    ensureAuthentication,
    (req, res, next) =&gt; {
      console.log(&apos;Token:&apos;, req.bearerToken);
      next();
    },
  ])];
});</code>
</code></pre><h2>Version validator</h2><p>A service-middleware to validate a <code>version</code> parameter against the configuration <code>version</code> setting. It&apos;s what the version validator middleware internally uses.</p><p>It&apos;s a <em>&quot;service-middleware&quot;</em> because when you access the service, it doesn&apos;t return a class instance, but a middleware function for you to use on your controller routes.</p><ul>
<li>Module: <code>api</code></li>
<li>Requires: <code>responsesBuilder</code> and <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    api: { versionValidator },
    common: { appError },
    http: { responsesBuilder },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(appError);
    this.register(responsesBuilder);

    // Register the service
    this.register(versionValidator);
  }
}</code>
</code></pre><p>Now you can use it on your controllers routes to validate that the version being used is the same as the one the app is running on:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myCtrl = controller((app) =&gt; {
  const router = app.get(&apos;router&apos;);
  const versionValidator = app.get(&apos;versionValidator&apos;);
  return [router.get(&apos;/:version/something&apos;, [
    versionValidator,
    (req, res, next) =&gt; {
      console.log(&apos;The version is valid!&apos;);
      next();
    },
  ])];
});</code>
</code></pre><h2>Error</h2><p>A very simple subclass of <code>Error</code> to inject extra information on the errors so they can customize the error handler responses.</p><p>Something important to remember is that the <code>appError</code> service doesn&apos;t return an instance of the service but the class so you can construct an error.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { appError },
  },
};

class App extends Jimpex {
  boot() {        
    // Register the service
    this.register(appError);
  }
}</code>
</code></pre><p>That&apos;s all, now you can do <code>get(&apos;appError&apos;)</code>, inject <code>AppError</code> and generate your custom errors:</p><pre><code class="lang-js"><code class="source-code prettyprint">new Error(&apos;Something happened&apos;, {
  someProp: &apos;someValue&apos;,
}):</code>
</code></pre><p>This is useful if you are building an app with multiple known exceptions, you can use the extra settings to send context information.</p><h2>Send File</h2><p>It allows you to send a file on a response with a path relative to the app executable.</p><p>The <code>sendFile</code> doesn&apos;t return a class service instance but just a function.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
};

class App extends Jimpex {
  boot() {        
    // Register the service
    this.register(sendFile);
  }
}</code>
</code></pre><p>Done, you can now use it on your middlewares and/or controllers routes to send files as responses:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myCtrl = controller((app) =&gt; {
  const router = app.get(&apos;router&apos;);
  const sendFile = app.get(&apos;sendFile&apos;);
  return [router.get(&apos;/something&apos;, [
    (req, res, next) =&gt; {
      sendFile(res, &apos;./something.html&apos;, next);
    },
  ])];
});</code>
</code></pre><p>By default, the path of the file is relative to the directory where the app executable is located, but you can change the location (<a href="https://github.com/homer0/wootils/blob/master/documents/node/pathUtils.md#multiple-locations">Check <code>PathUtils</code> locations</a>) by adding an extra parameter:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myCtrl = controller((app) =&gt; {
  const router = app.get(&apos;router&apos;);
  const sendFile = app.get(&apos;sendFile&apos;);
  return [router.get(&apos;/something&apos;, [
    (req, res, next) =&gt; {
      sendFile(res, &apos;./something.html&apos;, next, &apos;home&apos;);
    },
  ])];
});</code>
</code></pre><p>In this last example, the path to the file is relative to the project root directory.</p><h2>Frontend Fs</h2><p>This service allows the app to easily read static files. The idea behind centralizing this functionalities into a service is that is pretty common to have bundling tools to generate the frontend, and on that process files can have different paths or not even be generated all, that&apos;s why this service exists.</p><p> The service can be extended/overwritten to accommodate any requirements and avoid having to update or add <code>if</code>s to every <code>fs</code> call the app does. Another <em>&apos;feature&apos;</em> of this service is that all the paths are relative to the directory where the app executable is located, so you don&apos;t have to remember the relative path from the place you are accessing a file to the place where it&apos;s located.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    frontend: { frontendFs },
  },
};

class App extends Jimpex {
  boot() {        
    // Register the service
    this.register(frontendFs);
  }
}</code>
</code></pre><p>Now, whenever you are reading/writing/deleting a file that was generated/belongs to the frontend, you can use this service methods:</p><ul>
<li><code>.read(filepath, [encoding=&apos;utf-8&apos;])</code></li>
<li><code>.write(filepath, data)</code></li>
<li><code>.delete(filepath)</code></li>
</ul><h2>HTML Generator</h2><p>A service that allows you to generate an HTML file when the app gets started and inject contents of the configuration as a <code>window</code> variable.</p><ul>
<li>Module: <code>html</code></li>
<li>Requires: <code>frontendFs</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    frontend: { frontendFs },
    html: { htmlGenerator },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(frontendFs);

    // Register the service
    this.register(htmlGenerator);
  }
}</code>
</code></pre><p>The service, after registering, it also hooks itself to the app event that gets fired when it starts so it can create the file automatically.</p><p>Now, this service has a few default options, so instead of explaining which are, we&apos;ll see each option on detail:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The name of the file it should use as template.
  template: &apos;index.tpl.html&apos;,

  // The name of the generated file.
  file: &apos;index.html&apos;,

  // Whether or not to delete the template after generating the file.
  deleteTemplateAfter: true,

  // The placeholder string where the information will be written.
  replacePlaceholder: &apos;{{appConfiguration}}&apos;,

  // A dynamic placeholder to replace single values on the template.
  valuesExpression: /\{\{(.*?)\}\}/ig,

  // The name of the variable that will have the information on the file.
  variable: &apos;appConfiguration&apos;,

  // A list of settings from the app configuration that will be used as the
  // information to inject on the file.
  configurationKeys: [&apos;features&apos;, &apos;version&apos;, &apos;postMessagesPrefix&apos;],
}</code>
</code></pre><p>It also supports a custom service with a <code>getValues</code> method to obtain the information to inject instead of taking it from the configuration.</p><p>To modify the options, you need to use the <em>&quot;service generator&quot;</em> <code>htmlGeneratorCustom</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    frontend: { frontendFs },
    html: { htmlGeneratorCustom },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(frontendFs);

    // Register the service
    this.register(htmlGeneratorCustom({
      template: &apos;template.tpl&apos;,
      file: &apos;my-index.html&apos;,
      ...
    }));
  }
}</code>
</code></pre><p>The first parameter is the name of the service and the second the options to customize it. In case you want to use another service to get the values, you can send the name of that service as the third parameter.</p><h2>HTTP</h2><p>A set of utilities to work with HTTP requests and responses.</p><ul>
<li>Module: <code>http</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { http },
  },
};

class App extends Jimpex {
  boot() {
    // Register the service
    this.register(http);
  }
}</code>
</code></pre><p>The <code>http</code> service has three methods:</p><ul>
<li><code>getIPFromRequest(req)</code>: It allows you to get the IP address from an app request.</li>
<li><code>getCustomHeadersFromRequest(req)</code>: It returns a dictionary with all the custom headers a request may have, except for <code>x-forwarded-for</code>.</li>
<li><code>fetch(url, options)</code>: Probably the most important as is the one the app uses to make requests to external services. This service supports the same signature as the native <code>fetch</code> function, with the addition that you can send a request object as <code>req</code> on the options and the method will include the <code>x-forwarded-for</code> method with the request IP address (<code>getIPFromRequest</code>) and all the request custom headers (<code>getCustomHeadersFromRequest</code>).</li>
</ul><p>Also, if you have a configuration setting named <code>debug.logRequests</code> with the value of <code>true</code>, it will log information of all the outgoing requests and their responses on the console.</p><h2>Responses builder</h2><p>A service that generates JSON and HTML responses.</p><ul>
<li>Module: <code>http</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
  },
};

class App extends Jimpex {
  boot() {
    // Register the service
    this.register(responsesBuilder);
  }
}</code>
</code></pre><p>This service has only two methods:</p><ul>
<li><code>json(res, data, status = 200, metadata = {})</code>: To write regular JSON responses.</li>
<li><code>htmlPostMessage(res, title, message, status = 200, options = {})</code>: To write an HTML response that sends a post message. Very useful for when the app opened the route using a popup. The last parameter allows you to customize the HTML response:</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The target that will emit the `postMessage`.
  target: &apos;window.opener&apos;,

  //  Whether or not to do a `window.close` after sending the message.
  close: true,

  // How many ms should it wait before closing the window, if `options.close` is `true`.
  closeDelay: 700,  
}</code>
</code></pre></div>
        <a data-ice="link" href="manual/services.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
