<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | jimpex</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Express as dependency injection container."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="jimpex"><meta property="twitter:description" content="Express as dependency injection container."></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/jimpex"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/options.html"><a href="manual/options.html" data-ice="link">Jimpex Options</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#configuration" data-ice="link">Configuration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#statics" data-ice="link">Statics</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#express" data-ice="link">Express</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/options.html"><a href="manual/options.html#default-services" data-ice="link">Default services</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/controllers.html"><a href="manual/controllers.html" data-ice="link">Built-in Controllers</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#configuration" data-ice="link">Configuration</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#health" data-ice="link">Health</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#statics" data-ice="link">Statics</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/controllers.html"><a href="manual/controllers.html#gateway" data-ice="link">Gateway</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/middlewares.html"><a href="manual/middlewares.html" data-ice="link">Built-in Middlewares</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#error-handler" data-ice="link">Error Handler</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#force-https" data-ice="link">Force HTTPS</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#fast-html" data-ice="link">Fast HTML</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#show-html" data-ice="link">Show HTML</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/middlewares.html"><a href="manual/middlewares.html#version-validator" data-ice="link">Version validator</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/services.html"><a href="manual/services.html" data-ice="link">Built-in Services</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#api-client" data-ice="link">API Client</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#app-error" data-ice="link">App Error</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#ensure-bearer-token" data-ice="link">Ensure bearer token</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#http-error" data-ice="link">HTTP Error</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#send-file" data-ice="link">Send File</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#frontend-fs" data-ice="link">Frontend Fs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#html-generator" data-ice="link">HTML Generator</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#http" data-ice="link">HTTP</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/services.html"><a href="manual/services.html#responses-builder" data-ice="link">Responses builder</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Jimpex Options</h1><p>The options the second parameter of the class constructor and it allows you to customize almost every aspect of Jimpex.</p><p>This is what the options object looks like:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The version of the app
  version: &apos;0.0.0&apos;,

  // The size limit for the requests payload.
  filesizeLimit: &apos;15MB&apos;,

  // The options to customize how the app configuration is loaded (details on its section).
  configuration: ...,

  // The options for the static middleware (details on its section).
  statics: ...,

  // The options to customize the express instance and default middlewares (details on its section).
  express: ...,

  // Which built-in services to register (details on its section).
  defaultServices: ...
}</code>
</code></pre><p>Besides the first two, which default values and descriptions are pretty clear, I&apos;ll go in detail for all the others.</p><h2>Configuration</h2><p>This set of options allows you to customize every aspect of how the configuration service is created. Remember that the app requires a valid configuration with a <code>port</code> setting to be started:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The default configuration. If the value is null, it will load [app-name].config.js
  default: null,

  // The name of the app, to be used on the configurations directory and filenames.
  name: &apos;app&apos;,

  // The path relative to the root directory where the configurations are located.
  path: &apos;config/&apos;,

  // If `true`, the path to the configuration will add a folder with the name of the app.
  hasFolder: true,

  // The environment variable the app will check for a configuration name.
  environmentVariable: &apos;CONFIG&apos;,

  // Whether or not to check for the environment variable.
  loadFromEnvironment: true,

  // If `true`, the version of the app will be copied from the loaded configuration.
  loadVersionFromConfiguration: true,

  // The name format of the configuration files.
  filenameFormat: &apos;[app-name].[configuration-name].config.js&apos;,
}</code>
</code></pre><p>As you can see, if you don&apos;t want to depend on environment variables or just have one single configuration for your app, you can use the <code>default</code> option and turn <code>loadFromEnvironment</code> to <code>false</code>.</p><p>The configuration service is an implementation of <a href="https://github.com/homer0/wootils/blob/master/documents/node/appConfiguration.md">wootils AppConfiguration</a>, so you can check its API in its oficial configuration.</p><h2>Statics</h2><p>These options are specifically for the Express <a href="https://github.com/expressjs/serve-static"><code>static</code></a> middleware:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // Whether or not to enable the middleware to serve statics files.
  enabled: true,

  // If true, the statics folder would be relative to the project root directory, otherwise,
  // it would be relative to the app executable.
  onHome: false,

  // The name of both the route and the folder, relative to whatever you defined with the
  // `onHome` option.
  route: &apos;statics&apos;,

  // By default, the folder will be the same as the `route`, but you can use this option
  // to define a relative path that won&apos;t affect the route.
  folder: &apos;&apos;,
}</code>
</code></pre><h2>Express</h2><p>These are options for miscellaneous things you can add to the Express server:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // Whether or not to enable the `trust proxy` option.
  trustProxy: true,

  // Whether or not to remove the `x-powered-by` header.
  disableXPoweredBy: true,

  // Whether or not to add the `compression` middleware.
  compression: true,

  // Whether or not to add the `body-parser` middleware.
  bodyParser: true,

  // Whether or not to add the `multer` middleware.
  multer: true,
}</code>
</code></pre><h2>Default services</h2><p>These options allow you to register some of the built-in service that I consider useful enough to be added on any app.</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // These services include:
  // - Error handler
  // - Send File
  common: true,

  // These services include:
  // - API client
  // - HTTP
  // - Responses builder
  http: true,

  // These services include:
  // - Ensure bearer token
  utils: true,
}</code>
</code></pre><p>For more information about these services, check the document about <strong>Built-in Services</strong>.</p></div>
        <a data-ice="link" href="manual/options.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Built-in Controllers</h1><p>All of these controllers are available on the Jimpex package and can be easily required and implemented.</p><h2>Configuration</h2><p>Allows you to see and switch the current configuration. It can be enabled or disabled by using a setting on the configuration.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>responsesBuilder</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
  },
  controllers: {
    common: { configurationController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(responsesBuilder);

    // Add the controller.
    this.mount(&apos;/config&apos;, configurationController);
  }
}</code>
</code></pre><p>Now, there are two rules behind this controller:</p><ol>
<li>Your configuration must have a setting <code>debug.configurationController</code> with the value of <code>true</code>.</li>
<li>To be able to switch configurations, the default configuration and/or the first configuration loaded must have a setting <code>allowConfigurationSwitch</code> set to <code>true</code>.</li>
</ol><p>The reason for those rules is that this controller is development purposes as you wouldn&apos;t want to make public the settings of your app.</p><p>The controller then will mount two routes:</p><ul>
<li><code>GET /</code>: It will show the current configuration.</li>
<li><code>GET /switch/:name</code>: It will, if allowed, switch to an specified configuration.</li>
</ul><h2>Health</h2><p>Shows the version and name of the configuration, just to check the app is running.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>responsesBuilder</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
  },
  controllers: {
    common: { healthController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(responsesBuilder);

    // Add the controller.
    this.mount(&apos;/health&apos;, healthController);
  }
}</code>
</code></pre><p>That&apos;s all there is, the controller mounts only one route:</p><ul>
<li><code>GET /</code>: Shows the information.</li>
</ul><h2>Statics</h2><p>It allows your app to server specific files from any directory, without having to use the <code>static</code> middleware.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>sendFile</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  controllers: {
    common: { staticsController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the controller.
    this.mount(&apos;/&apos;, staticsController);
  }
}</code>
</code></pre><p>The controller comes with a lot of default options:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The list of files it will serve.
  files: [&apos;favicon.ico&apos;, &apos;index.html&apos;],
  // The HTTP methods for which it will mount routes.
  methods: {
    // If `all` is `true`, then all the others are ignored.
    all: false,
    get: true,
  },
  // The &quot;master&quot; paths to prepend to all file routes and files.
  paths: {
    // The base route from where the files are going to be served.
    route: &apos;&apos;,
    // The base path from where the files are located.
    source: &apos;./&apos;,
  },
}</code>
</code></pre><p>All of those values can be customized by calling the controller as a function:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  controllers: {
    common: { staticsController },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the controller.
    this.mount(&apos;/&apos;, staticsController({
      paths: {
        route: &apos;public&apos;,
        source: &apos;secret-folder&apos;,
      }
      files: [
        &apos;my-file-one.html&apos;,
        &apos;favicon.icon&apos;,
        &apos;index.html&apos;,
        &apos;some-other.html&apos;,
      ],
    }));
  }
}</code>
</code></pre><p>You can also specify custom information to each individual file:</p><pre><code class="lang-js"><code class="source-code prettyprint">this.mount(&apos;/&apos;, staticsController({
  files: [
    &apos;my-file-one.html&apos;,
    {
      route: &apos;favicon.ico&apos;,
      source: &apos;icons/fav/icon.ico&apos;,
      headers: {
        &apos;X-Custom-Icon-Header&apos;: &apos;Something!&apos;,
      },
    },
    &apos;index.html&apos;,
  ],
}));</code>
</code></pre><p>Finally, you can also add a custom middleware or middlewares to the routes created by the controller, you just need to send a function that returns the middlewares when called.</p><pre><code class="lang-js"><code class="source-code prettyprint">/**
 * In this case, we&apos;ll use Jimpex&apos;s `ensureBearerToken` to protect the
 * file routes.
 */
const filesProtection = (app) =&gt; [app.get(&apos;ensureBearerToken&apos;)];

this.mount(&apos;/&apos;, staticsController(
  {
    files: [
      &apos;index.html&apos;,
    ],
  },
  [filesProtection]
));</code>
</code></pre><p>And that&apos;s all, the middleware will be added to the route, just before serving the file.</p><h2>Gateway</h2><p>It allows you to automatically generate a set of routes that will make gateway requests to an specific API.</p><ul>
<li>Module: <code>utils</code></li>
<li>Requires: <code>http</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { http },
  },
  controllers: {
    utils: { gateway },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(http);

    // Add the controller.
    this.mount(&apos;/gateway&apos;, gateway);
  }
}</code>
</code></pre><p>The controller will automatically look into your app configuration for a key called <code>api</code> with the following format:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  url: &apos;api-entry-point&apos;,
  gateway: {
    endpointOne: &apos;endpoint/one/path&apos;,
  },
}</code>
</code></pre><blockquote>
<p>Yes, the format is almost the same as the API Client.</p>
</blockquote><p>Based on the example above and that configuration, the controller would mount a route on <code>/gateway/endpoint/one/path</code> that would fire a request to <code>api-entry-point/endpoint/one/path</code>.</p><p>The controller has a few options that you can customize:</p><pre><code class="lang-js"><code class="source-code prettyprint">{

  // The name that will be used to register the controller as a sevice (yes!),
  // so other services can access the API Client configuration the controller
  // generates from its routes.

  serviceName: &apos;apiGateway&apos;,

  // The name of a registered service that will work as a helper, and that the
  // controller will call in order to modify requests, responses and even handle
  // errors.
  helperServiceName: &apos;apiGatewayHelper&apos;,

  // The name of the configuration setting where the gateway configuration is stored.
  // This is also used to wrap the endpoints on the generated API Client configuration.
  configurationSetting: &apos;api&apos;,

  // This is a helper for when the gateway is used with an API client. The idea is
  // that, by default, the routes are mounted on the controller route, but with
  // this option, you can specify another sub path. For example: The controller
  // is mounted on `/routes`, if you set `root` to `gateway`, all the routes will
  // be on `/routes/gateway`.
  root: &apos;&apos;,

  // How the gateway will handle headers from requests and responses.
  headers: {

    // Whether or not to include the header with a request real IP.
    useXForwardedFor: true,

    // Whether or not to copy the custom headers (the ones that start with `x-`).
    copyCustomHeaders: true,

    // A list of headers that will be copied from the incoming request into the
    // fetch request.
    copy: [
      &apos;authorization&apos;,
      &apos;content-type&apos;,
      &apos;referer&apos;,
      &apos;user-agent&apos;,
    ],

    // A list of headers that will be removed while copying the headers from a
    // fetch response into the server&apos;s response.
    remove: [
      &apos;server&apos;,
      &apos;x-powered-by&apos;,
    ],
  },
}</code>
</code></pre><p>The way you overwrite them is by calling the controller as a function:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { http },
  },
  controllers: {
    utils: { gateway },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(http);

    // Add the controller.
    this.mount(&apos;/gateway&apos;, gateway({
      serviceName: &apos;Batman&apos;,
    }));
  }
}</code>
</code></pre><p>I strongly recommend you to read the techinical documentation in order to know all the things you
can do with the helper service and the logic behind the naming convetion the controller creator enforces (the <code>serviceName</code> must end with <code>Gateway</code>, among other things).</p></div>
        <a data-ice="link" href="manual/controllers.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Built-in Middlewares</h1><p>All of these controllers are available on the Jimpex package and can be easily required and implemented.</p><h2>Error Handler</h2><p>Allows you to generate responses for errors and potentially hide uncaught exceptions under a generic message, unless it&apos;s disabled via configuration settings.</p><ul>
<li>Module: <code>common</code></li>
<li>Requires: <code>responsesBuilder</code> and <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
    common: { appError },
  },
  middlewares: {
    common: { errorHandler },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(responsesBuilder);
    this.register(appError);

    ...

    // Add the middleware at the end.
    this.use(errorHandler);
  }
}</code>
</code></pre><p>Now, there&apos;s a configuration setting for this controller: <code>debug.showErrors</code>. By enabling the setting, the middleware will show the message and the stack information of all kind of errors.</p><p>If the configuration setting is disabled (or not present), the errors stack will never be visible, and if the error is not an instance of <code>AppError</code>, it will show a generic message.</p><p>By default, the generic message is <em>&quot;Oops! Something went wrong, please try again&quot;</em> and the default HTTP status is <code>500</code>, but you can use it as a function to modify those defaults:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
    common: { appError },
  },
  middlewares: {
    common: { errorHandler },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(responsesBuilder);
    this.register(appError);

    ...

    // Add the middleware at the end.
    this.use(errorHandler({
      default: {
        message: &apos;Unknown error&apos;,
        status: 503,
      },
    }));
  }
}</code>
</code></pre><p>Finally, when using errors of the type <code>AppError</code>, you can add the following context information:</p><pre><code class="lang-js"><code class="source-code prettyprint">// Assuming `AppError` is the injected `AppError` and you are on the context of a middleware
next(new AppError(&apos;Something went wrong&apos;, {
  status: someHTTPStatus,
  response: someObject,
}));</code>
</code></pre><ul>
<li><code>status</code> will replace the error responses HTTP status.</li>
<li><code>response</code> will be merged into the error response <code>data</code> key.</li>
</ul><h2>Force HTTPS</h2><p>Redirect all incoming traffic from HTTP to HTTPS. It also allows you to set routes to ignore the redirection.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  middlewares: {
    common: { forceHTTPS },
  },
};

class App extends Jimpex {
  boot() {
    // Add the middleware first.
    this.use(errorHandler);
  }
}</code>
</code></pre><p>By default, it redirects all the URLs that don&apos;t start with <code>/service/</code> from HTTP to HTTPs, but you can use it as a function to modify the rules:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  middlewares: {
    common: { forceHTTPS },
  },
};

class App extends Jimpex {
  boot() {
    // Add the middleware first.
    this.use(forceHTTPS([
      /^\/service\//,
      /^\/api\//,
    ]));
  }
}</code>
</code></pre><p><strong>VERY IMPORTANT:</strong> The forced redirection will only happen if your configuration has a setting named <code>forceHTTPS</code> with a value of <code>true</code>.</p><h2>Fast HTML</h2><p>Allows your app to skip unnecessary processing by showing an specific HTML when a requested route doesn&apos;t have a controller for it or is not on a &quot;whitelist&quot;</p><ul>
<li>Module: <code>html</code></li>
<li>Requires: <code>events</code>, <code>sendFile</code> and, optionally, an <code>HTMLGenerator</code> service.</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { fastHTML },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware on one of the first positions.
    this.use(fastHTML);
  }
}</code>
</code></pre><p>The middleware has a few options with default values that can be customized:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The name of the file it will serve.
  file: &apos;index.html&apos;,
  // A list of expressions for routes that should be ignored.
  ignore: [/\.ico$/i],
  // Whether or not to use the routes controlled by the app to validate the requests.
  useAppRoutes: true,
  // The name of the HTML Generator service the middleware can use to obtain the HTML. 
  htmlGenerator: &apos;htmlGenerator&apos;,
}</code>
</code></pre><p>You can customize all those options by just calling the middleware as a function:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { fastHTML },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware on one of the first positions.
    this.use(fastHTML({
      file: &apos;my-custom-index.html&apos;,
      ignore: [`/^\/service\//`],
      useAppRoutes: false,
      htmlGenerator: null, // To disable it.
    }));
  }
}</code>
</code></pre><p>Now, as mentioned on the requirements, you can optionally use the <code>htmlGenerator</code> service or an <code>HTMLGenerator</code>-like service to serve a generated file.</p><p>You use the <code>htmlGenerator</code> option to disable it, or modify the name of the service it will look for:</p><ul>
<li>If you set it to a <em>&quot;falsy&quot;</em> value, it will be disabled.</li>
<li>If you change its name, it will try to look for that service when mounted.</li>
</ul><p><strong>Important:</strong> When using the generator, no matter the value you set on the <code>file</code> option, it will overwritten with the name of the file from the generator service.</p><h2>Show HTML</h2><p>A really simple middleware to serve an HTML file. Its true feature is that it can be hooked up to the <strong>HTML Generator</strong> service.</p><ul>
<li>Module: <code>html</code></li>
<li>Requires: <code>sendFile</code> and, optionally, an <code>HTMLGenerator</code> service.</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { showHTML },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware at the end.
    this.use(showHTML);
  }
}</code>
</code></pre><p>By default, if the middleware is reached, it will show an <code>index.html</code>, but you can use it as a function to modify the filename:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
  middlewares: {
    html: { showHTML },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(sendFile);

    // Add the middleware at the end.
    this.use(showHTML(&apos;my-file.html&apos;));
  }
}</code>
</code></pre><p>Now, as mentioned on the requirements, you can optionally use the <code>htmlGenerator</code> or an <code>HTMLGenerator</code> service to show the generated file.</p><p>The default implementation checks if there&apos;s an <code>htmlGenerator</code> service registered on the app and uses that file; and in the case of <code>showHTML</code>, you can specify a second parameter with the name of the <code>HTMLGenerator</code> service name you want to use.</p><h2>Version validator</h2><p>This can be used as a middleware and as controller. The idea is that it validates a <code>version</code> parameter against the version defined on the configuration.</p><ul>
<li>Module: <code>utils</code></li>
<li>Requires: <code>appConfiguration</code>, <code>responsesBuilder</code> and <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  middlewares: {
    utils: { versionValidator },
  },
};

class App extends Jimpex {
  boot() {
    // Add the middleware before the routes you want to be protected.
    this.use(versionValidator);
    // or, protect a specific route.
    this.mount(&apos;/to-protect&apos;, versionValidator);
  }
}</code>
</code></pre><p>By default, it comes with a lot of already defined options, like whether or not to allow <code>latest</code> as a version, but you can use it as a function to modify them, for example:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  middlewares: {
    utils: { versionValidator },
  },
};

class App extends Jimpex {
  boot() {
    // Add the middleware before the routes you want to be protected.
    this.use(versionValidator({
      latest: {
        allow: false,
      }
    }));
    // or, protect a specific route.
    this.mount(&apos;/to-protect&apos;, versionValidator({
      latest: {
        allow: false,
      }
    }));
  }
}</code>
</code></pre><p><strong>Very important:</strong> The middleware will only validate if <code>req.params.version</code> is found.</p></div>
        <a data-ice="link" href="manual/middlewares.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Built-in Services</h1><p>All of these controllers are available on the Jimpex package and can be easily required and implemented.</p><p>In the case of the services from the modules <code>api</code>, <code>http</code> and <code>common</code>, you can register them when the app starts by using the <code>defaultService</code> option (Check the options document for more information).</p><h2>API Client</h2><p>An implementation of the <a href="https://github.com/homer0/wootils/blob/master/documents/shared/APIClient.md">wootils API Client</a> but that is connected to the HTTP service, to allow logging and forwarding of the headers.</p><ul>
<li>Module: <code>http</code></li>
<li>Requires: <code>http</code> and <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { appError },
    http: { apiClient, http },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(http);
    this.register(appError);

    // Register the client
    this.register(apiClient);
  }
}</code>
</code></pre><p>The service has a few options that can be customized:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The name the service will have in the container; in case you need more than one.
  serviceName: &apos;apiClient&apos;,

  // The name of the configuration setting that will contain the API `url` and `endpoints`.
  // If this is not customized, but the `serviceName` is, this value will be set to the
  // same as the `serviceName`.
  configurationSetting: &apos;api&apos;,

  // The class the service will instantiate. This is in case you end up extending the
  // base one in order to add custommethods.
  clientClass: APIClient,
}</code>
</code></pre><p>You can use the provider as a function to modify the options:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { appError },
    http: { apiClient, http },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(http);
    this.register(appError);

    // Register the client
    this.register(apiClient({
      serviceName: &apos;myCustomAPIService&apos;,
      configurationSetting: &apos;myapi&apos;,
    });
  }
}</code>
</code></pre><h2>App Error</h2><p>A very simple subclass of <code>Error</code> but with support for context information. It can be used to customize the error handler responses.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { appError },
  },
};

class App extends Jimpex {
  boot() {        
    // Register the service
    this.register(appError);
  }
}</code>
</code></pre><p>By registering the &quot;service&quot;, two things are added to the container: The class declaration, so you can construct the errors, and a shorthand function that does the same:</p><pre><code class="lang-js"><code class="source-code prettyprint">const AppError = app.get(&apos;AppError&apos;);
throw new AppError(&apos;Something happened&apos;, {
  someProp: &apos;someValue&apos;,
});
// or
const appError = app.get(&apos;appError&apos;);
throw appError(&apos;Something happened&apos;, {
  someProp: &apos;someValue&apos;,
});</code>
</code></pre><p>This is useful if you are building an app with multiple known exceptions, you can use the context to send useful information.</p><h2>Ensure bearer token</h2><p>A service-middleware that allows you to validate and retrieve a bearer token from the incoming requests <code>Authorization</code> header.</p><p>It&apos;s a <em>&quot;service-middleware&quot;</em> because when you access the service, it doesn&apos;t return a class/service instance, but a middleware function for you to use on your controller routes.</p><ul>
<li>Module: <code>utils</code></li>
<li>Requires: <code>appError</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { appError },
    utils: { ensureBearerToken },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(appError);

    // Register the service
    this.register(ensureBearerToken);
  }
}</code>
</code></pre><p>This service has a few default options:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The information for the error generated when no token is found.
  error: {
    // The error message.
    message: &apos;Unauthorized&apos;,
    // The HTTP status associated to the error, this is for the error handler.
    status: statuses.unauthorized,
    // Extra context information for the error handler to add to the response.
    response: {},
  },
  // The regular expression used to validate and extract the token.
  expression: /bearer (.*?)(?:$|\s)/i,
  // The name of the property on `res.locals` where the token will be saved.
  local: &apos;token&apos;,
}</code>
</code></pre><p>You modify those default values by using the provider as a function when registering:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { appError },
    utils: { ensureBearerToken },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(appError);

    // Register the service
    this.register(ensureBearerToken({
      error: {
        message: &apos;You are not authorized to access this route&apos;,
      },
      local: &apos;userToken&apos;,
    }));
  }
}</code>
</code></pre><p>Now, if the token processes a request and detects a valid token, it will save it on <code>res.locals.token</code>:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myCtrl = controller((app) =&gt; {
  const router = app.get(&apos;router&apos;);
  const ensureBearerToken = app.get(&apos;ensureBearerToken&apos;);
  return [router.get(&apos;/something&apos;, [
    ensureBearerToken,
    (req, res, next) =&gt; {
      console.log(&apos;Token:&apos;, res.locals.token);
      next();
    },
  ])];
});</code>
</code></pre><h2>HTTP Error</h2><p>Another type of error, but specific for the HTTP requests the app does with the API client. This is a subclass of <code>AppError</code>. The only advantage over <code>AppError</code> is that you know the that the type of error is specific to requests and that it has a paramter for an HTTP status.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { httpError },
  },
};

class App extends Jimpex {
  boot() {        
    // Register the service
    this.register(httpError);
  }
}</code>
</code></pre><p>By registering the &quot;service&quot;, two things are added to the container: The class declaration, so you can construct the errors, and a shorthand function that does the same:</p><pre><code class="lang-js"><code class="source-code prettyprint">const HTTPError = app.get(&apos;HTTPError&apos;);
throw new AppError(&apos;Not found&apos;, 404);
// or
const httpError = app.get(&apos;httpError&apos;);
throw httpError(&apos;Not found&apos;, 404);</code>
</code></pre><h2>Send File</h2><p>It allows you to send a file on a response with a path relative to the app executable.</p><p>The <code>sendFile</code> doesn&apos;t return a class service instance but just a function.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    common: { sendFile },
  },
};

class App extends Jimpex {
  boot() {        
    // Register the service
    this.register(sendFile);
  }
}</code>
</code></pre><p>Done, you can now use it on your middlewares and/or controllers routes to send files as responses:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myCtrl = controller((app) =&gt; {
  const router = app.get(&apos;router&apos;);
  const sendFile = app.get(&apos;sendFile&apos;);
  return [router.get(&apos;/something&apos;, [
    (req, res, next) =&gt; {
      sendFile(res, &apos;./something.html&apos;, next);
    },
  ])];
});</code>
</code></pre><p>By default, the path of the file is relative to the directory where the app executable is located, but you can change the location (<a href="https://github.com/homer0/wootils/blob/master/documents/node/pathUtils.md#multiple-locations">Check <code>PathUtils</code> locations</a>) by adding an extra parameter:</p><pre><code class="lang-js"><code class="source-code prettyprint">const myCtrl = controller((app) =&gt; {
  const router = app.get(&apos;router&apos;);
  const sendFile = app.get(&apos;sendFile&apos;);
  return [router.get(&apos;/something&apos;, [
    (req, res, next) =&gt; {
      sendFile(res, &apos;./something.html&apos;, next, &apos;home&apos;);
    },
  ])];
});</code>
</code></pre><p>In this last example, the path to the file is relative to the project root directory.</p><h2>Frontend Fs</h2><p>This service allows the app to easily read static files. The idea behind centralizing this functionalities into a service is that is pretty common to have bundling tools to generate the frontend, and on that process files can have different paths or not even be generated all, that&apos;s why this service exists.</p><p> The service can be extended/overwritten to accommodate any requirements and avoid having to update or add <code>if</code>s to every <code>fs</code> call the app does. Another <em>&apos;feature&apos;</em> of this service is that all the paths are relative to the directory where the app executable is located, so you don&apos;t have to remember the relative path from the place you are accessing a file to the place where it&apos;s located.</p><ul>
<li>Module: <code>common</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    frontend: { frontendFs },
  },
};

class App extends Jimpex {
  boot() {        
    // Register the service
    this.register(frontendFs);
  }
}</code>
</code></pre><p>Now, whenever you are reading/writing/deleting a file that was generated/belongs to the frontend, you can use this service methods:</p><ul>
<li><code>.read(filepath, [encoding=&apos;utf-8&apos;])</code></li>
<li><code>.write(filepath, data)</code></li>
<li><code>.delete(filepath)</code></li>
</ul><h2>HTML Generator</h2><p>A service that allows you to generate an HTML file when the app gets started and inject contents of the configuration as a <code>window</code> variable.</p><ul>
<li>Module: <code>html</code></li>
<li>Requires: <code>frontendFs</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    frontend: { frontendFs },
    html: { htmlGenerator },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(frontendFs);

    // Register the service
    this.register(htmlGenerator);
  }
}</code>
</code></pre><p>The service, after registering, it hooks itself to the app event that gets fired when it starts, so it can create the file automatically.</p><p>Now, this service has a few default options, so instead of explaining which are, we&apos;ll see each option on detail:</p><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The name the service will have in the container; in case you need more than one.
  serviceName: &apos;htmlGenerator&apos;,

  // The name of a service from will it obtain the values for the template. When
  // instantiated, it will look for it on the container, and if is not avaiable,
  // it will just ignore it and use `configurationKeys`.
  // You can completely by setting the value to `null`.
  valuesService: &apos;htmlGeneratorValues&apos;,

  // The name of the file it should use as template.
  template: &apos;index.tpl.html&apos;,

  // The name of the generated file.
  file: &apos;index.html&apos;,

  // Whether or not to delete the template after generating the file.
  deleteTemplateAfter: true,

  // The placeholder string where the information will be written.
  replacePlaceholder: &apos;{{appConfiguration}}&apos;,

  // A dynamic placeholder to replace single values on the template.
  valuesExpression: /\{\{(.*?)\}\}/ig,

  // The name of the variable that will have the information on the file.
  variable: &apos;appConfiguration&apos;,

  // A list of settings from the app configuration that will be used as the
  // information to inject on the file.
  configurationKeys: [&apos;features&apos;, &apos;version&apos;, &apos;postMessagesPrefix&apos;],
}</code>
</code></pre><p>To modify the options, you just need to use provider as a function:</p><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    frontend: { frontendFs },
    html: { htmlGenerator },
  },
};

class App extends Jimpex {
  boot() {
    // Register the dependencies...
    this.register(frontendFs);

    // Register the service
    this.register(htmlGenerator({
      template: &apos;template.tpl&apos;,
      file: &apos;my-index.html&apos;,
      ...
    }));
  }
}</code>
</code></pre><h2>HTTP</h2><p>A set of utilities to work with HTTP requests and responses.</p><ul>
<li>Module: <code>http</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { http },
  },
};

class App extends Jimpex {
  boot() {
    // Register the service
    this.register(http);
  }
}</code>
</code></pre><p>The <code>http</code> service has three methods:</p><ul>
<li><code>getIPFromRequest(req)</code>: It allows you to get the IP address from an app request.</li>
<li><code>getCustomHeadersFromRequest(req)</code>: It returns a dictionary with all the custom headers a request may have, except for <code>x-forwarded-for</code>.</li>
<li><code>fetch(url, options)</code>: Probably the most important as is the one the app uses to make requests to external services. This service supports the same signature as the native <code>fetch</code> function, with the addition that you can send a request object as <code>req</code> on the options and the method will include the <code>x-forwarded-for</code> method with the request IP address (<code>getIPFromRequest</code>) and all the request custom headers (<code>getCustomHeadersFromRequest</code>).</li>
</ul><p>Also, if you have a configuration setting named <code>debug.logRequests</code> with the value of <code>true</code>, it will log information of all the outgoing requests and their responses on the console.</p><h2>Responses builder</h2><p>A service that generates JSON and HTML responses.</p><ul>
<li>Module: <code>http</code></li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">const {
  Jimpex,
  services: {
    http: { responsesBuilder },
  },
};

class App extends Jimpex {
  boot() {
    // Register the service
    this.register(responsesBuilder);
  }
}</code>
</code></pre><p>This service has only two methods:</p><ul>
<li><code>json(res, data, status = 200, metadata = {})</code>: To write regular JSON responses.</li>
<li><code>htmlPostMessage(res, title, message, status = 200, options = {})</code>: To write an HTML response that sends a post message. Very useful for when the app opened the route using a popup. The last parameter allows you to customize the HTML response:</li>
</ul><pre><code class="lang-js"><code class="source-code prettyprint">{
  // The target that will emit the `postMessage`.
  target: &apos;window.opener&apos;,

  //  Whether or not to do a `window.close` after sending the message.
  close: true,

  // How many ms should it wait before closing the window, if `options.close` is `true`.
  closeDelay: 700,  
}</code>
</code></pre></div>
        <a data-ice="link" href="manual/services.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
